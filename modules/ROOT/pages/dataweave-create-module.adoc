= Create Custom Modules and Mappings
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: studio, anypoint, esb, transform, transformer, format, aggregate, rename, split, filter convert, xml, json, csv, pojo, java object, metadata, dataweave, data weave, datamapper, dwl, dfl, dw, output structure, input structure, map, mapping


In addition to using the built-in DataWeave function modules (such as xref:dw-core.adoc[dw::Core] and xref:dw-crypto.adoc[dw::Crypto]), you can also create and use custom modules and mapping files.
The examples demonstrate common data extraction and transformation approaches.
//LINK TO DW 1.0 LANDING PAGE IN MULE 3.9 DOCS:
include::partial$dataweave1-links.adoc[tag=dataweave1LandingPage]

You write modules and mapping files in a DataWeave Language (`.dwl`) file and import into your Mule app through DataWeave scripts in Mule components. Both modules and mapping files are useful when you need to reuse the same functionality or feature over and over again.

* Custom modules can define functions, variables, types, and namespaces. You can import these modules into a DataWeave script to use the features.
* Custom mapping files are a type of module that contains a complete DataWeave script that you can import and use in another DataWeave script or reference in a Mule component.

Fields in many Mule connectors and components accept DataWeave expressions and scripts.

Note that if you want to import and use a built-in DataWeave function module, and not a custom one, see xref:dw-functions.adoc[DataWeave Function Reference].

[[create_dw_mapping]]
== Creating and Using DataWeave Mapping Files

You can store a DataWeave transformation in a `.dwl` mapping file (mapping module), then import the file into another DataWeave script. Mapping files can be executed through the Transform Message component, or you can import them into another mapping and execute them through the `main` function.

.Example: DataWeave Mapping File in a Studio Project
image::dataweave-mapping-file.png[Example: DataWeave Mapping File]

. In your Studio project, set up a subfolder and file for your mapping module:
+
* You can create a subfolder in `src/main/resources` by navigating to New -> Folder -> [your_project] -> `src/main/resources`, then adding a folder named `modules`.
* You can create a new file for your module in that folder by navigating to New -> File -> [your_project] -> `src/main/resources/modules`, then adding a DWL (DataWeave language) file such as `MyMapping.dwl`.
+
Saving the module within `src/main/resources` makes it accessible for use in a DataWeave script.  component in a Mule app in that project.
+
. Create your function in your mapping file, for example:
+
[[mapping_file]]
.Example: Mapping File Content
[source,dataweave,linenums]
----
%dw 2.0
import dw::core::Strings
fun capitalizeKey(value:String) = Strings::capitalize(value) ++ "Key"
---
payload mapObject ((value, key) ->
    {
      (capitalizeKey(key as String)) : value
    }
  )
----
+
. Save your DWL function module file.

=== Using a Mapping File in a DataWeave Script

To use a mapping file, you need to import it into a DataWeave script and use the `main` function to access the body of the script in the mapping file.

Assume that you have created the <<mapping_file, MyMapping.dwl>> file in `/src/main/resources/modules` that contains this script.

To import and use the body expression from the `MyMapping.dwl` file (above) in  DataWeave Mapping file, you need to do this:

* Specify the `import` directive in the header.
* Invoke the `MyMapping::main` function. The function expects an input that follows the structure of the input that the mapping file uses. For example, the body of `MyMapping.dwl` expects an object of the form `{"key" : "value"}`.

.Example: Importing and Using the Mapping in a DataWeave Script
[source,dataweave,linenums]
----
%dw 2.0
import modules::MyMapping
output application/json
---
MyMapping::main(payload: { "user" : "bar" })
----

Here is the result:

.Output
[source,json,linenums]
----
{
  "UserKey": "bar"
}
----

Even though the <<mapping_file, capitalizeKey>> function is private, it is still used through the `main` function call, and the DataWeave mapping file is also able to import and reuse the `dw::core::Strings` module.


== Creating and Using a Custom Module

The steps for creating a custom DataWeave module are almost identical to the steps for creating a custom mapping file. The only difference is the contents of the `.dwl` file. Unlike a typical DataWeave script or mapping file, a custom DataWeave
module cannot contain an `output` directive, body expression, or the separator (`---`) between header and body sections. (For
guidance with mappings, see <<create_dw_mapping>>.)

.Example: Custom Module in a Studio Project
image::dataweave-function-custom.png[Example: DataWeave Custom Function Module]

A custom module file can only contain `var`, `fun`, `type`, and `ns` declarations, for example:

[[example_custom_dw_module]]
.Example: Custom DataWeave Module
[source,dataweave,linenums]
----
%dw 2.0
fun myFunc(myInput: String) = myInput ++ "_"
var name = "MyData"
ns mynamespace http://acme.com/bar
----

When you import a custom module into another DataWeave script, any functions, variables, types, and namespaces defined in the module become available for use in the DataWeave body. In the next example, a DataWeave script:

* Imports the module `MyModule` through the `import` directive in the header. In this case, the imported module is stored in a Studio project path `src/main/resources/modules/MyModule.dwl`
* Calls a function in `MyModule` by using `MyModule::myFunc("dataweave")`.

.Example: Importing and Using a Custom DataWeave Module
[source,dataweave,linenums]
----
%dw 2.0
import modules::MyModule
output application/json
---
MyModule::myFunc("dataweave") ++ "name"
----

There are several ways to import a module or elements in it:

* Import the module, for example: `import modules::MyModule`. In this case, you must include the name of the module when you call the element (here, a function) in it, for example: `MyModule::myFunc`.
* Import all elements from the module, for example: `import * from modules::MyModule`. In this case, you do not need to include the name of the module when you call the element. For example: `myFunc("dataweave") ++ "name"` works.
* Import specific elements from a module, for example: `import myFunc from modules::MyModule`. In this case, you do not need to include the name of the module when you call the element. For example: `myFunc("dataweave") ++ "name"` works. You can import multiple elements from the module like this, for example: `import myFunc someOtherFunction from modules::MyModule` (assuming both `myFunc` and `someOtherFunction` are defined in the module).

.Output
[source,json,linenums]
----
"dataweave_name"
----

== Assigning a Local Alias for an Imported Element

To avoid name clashes, you can use `as` to assign an alias for a custom module or its elements when you import the module into a DataWeave script.

Assume that you define a custom module like this one in the file `MyModule.dwl`:

.Example: Custom Module
[source,dataweave,linenums]
----
%dw 2.0
fun myFunc(name:String) = name ++ "_"
var myVar = "Test"
----

When you import the custom module into a DataWeave script, you can create aliases to elements in the custom module, for example:

.Example: Applying an Alias to Imported Elements
[source,dataweave,linenums]
----
%dw 2.0
import myFunc as appendDash, myVar as weaveName from modules::MyModule
var myVar = "Mapping"
output application/json
---
appendDash("dataweave") ++ weaveName ++ "_" ++ myVar
----

The script returns `"dataweave_Test_Mapping"`. 

You can create an alias to the imported module, for example:

.Example: Applying an Alias to an Imported Module
[source,dataweave,linenums]
----
%dw 2.0
import modules::MyModule as WeaveMod
output application/json
---
WeaveMod::myFunc("dataweave")
----

== Referencing a DWL File

You can use DWL files directly in Mule connectors and components.

See xref:dataweave-language-introduction.adoc#dwl_file[dwl File] for details.

== DataWeave Documentation
DataWeave uses Asciidoc Language to document your functions, modules, and, types.

=== How to document your function
We defined a template to document your function code properly.

There are three main sections: _Description_, _Parameters_, and _Example_.

We use Asciidoc heading grammar to separate each section. 
So the valid headings are:

* `=== Parameters`

* `=== Example`
** `=== Source`
** `=== Input`
** `=== Output`

Below you can find the function document template.
....
%Replace with your function description%

%Add additional information to your function description% (optional section)

=== Parameters (optional section)

[%header, cols="1,1,3"]
|===
| Name | Type | Description
| %The parameter name% | %The parameter type% | %The parameter description%  (one row per param)
|===

=== Example (optional section)

%The example description% (optional)

==== Source (optional section)

[source,%The language%,linenums] (optional)
----
YOUR CODE
----

==== Input (optional section)

The input description (optional)

[source,%The language%,linenums] (optional)
----
YOUR CODE
----

==== Output (optional section)

%The output description% (optional)

[source,%The language%,linenums] (optional)
----
YOUR CODE
----
....


==== Description Section
In this section, you describe what your function does.
The description section starts from the beginning of the documentation until a heading section appears.

We distinguish two sub-section: _main description_ and _additional description_.

The _main description_ is the first paragraph and the rest of the
section until some of the heading sections appear, is the _additional description_.

These sub-sections are useful for the auto-generated documentation

==== Parameters Section
Describe the parameters needed for your function.

We use the Asciidoc grammar table to document the function parameters where every parameter function is a row in this table.

This section is optional, so you can omit it if your function
does not require any parameter.

==== Example Section
You can use zero or more _Example_ sections to document your function.
All the examples you need to document your function properly.

The _Example_ section contains 3 optional sub-section: _Input_, _Source_, and _Output_.
All of them use the same template, an optional description, and an optional code section.
....
Your section description

[source,%The language%,linenums]
----
YOUR CODE
----
....

The below example is the xref:dw-core-functions-log.adoc[log] function documentation.

....
/**
* Without changing the value of the input, `log` returns the input as a system
* log. So this makes it very simple to debug your code, because any expression or subexpression can be wrapped
* with *log* and the result will be printed out without modifying the result of the expression.
* The output is going to be printed in application/dw format.
* (1)
*
* The prefix parameter is optional and allows to easily find the log output.
*
*
* Use this function to help with debugging DataWeave scripts. A Mule app
* outputs the results through the `DefaultLoggingService`, which you can see
* in the Studio console.
*
* === Parameters
*
* [%header, cols="1,13"]
* |===
* | Name | Description
* | prefix | An optional string that typically describes the log.
* | value | The value to log.
* |===
*
* === Example
*
* This example logs the specified message. Note that the `DefaultLoggingService`
* in a Mule app that is running in Studio returns the message
* `WARNING - "Houston, we have a problem,"` adding the dash `-` between the
* prefix and value. The Logger component's `LoggerMessageProcessor` returns
* the input string `"Houston, we have a problem."`, without the `WARNING` prefix.
*
* ==== Source
*
* [source,DataWeave,linenums]
* ----
* %dw 2.0
* output application/json
* ---
* log("WARNING", "Houston, we have a problem")
* ----
*
* ==== Output
*
* `Console Output`
*
* [source,XML,linenums]
* ----
* "WARNING - Houston, we have a problem"
* ----
*
* `Expression Output`
*
* [source,XML,linenums]
* ----
* "Houston, we have a problem"
* ----
*
* === Example
*
* This example shows how to log the result of expression `myUser.user` without modifying the
* original expression `myUser.user.friend.name`.
*
* ==== Source
*
* [source,DataWeave,linenums]
* ----
* %dw 2.0
* output application/json
*
* var myUser = {user: {friend: {name: "Shoki"}, id: 1, name: "Tomo"}, accountId: "leansh" }
* ---
* log("User", myUser.user).friend.name
* ----
*
* ==== Output
*
* `Console output`
*
* [source,console,linenums]
* ----
* User - {
*   friend: {
*     name: "Shoki"
*   },
*   id: 1,
*   name: "Tomo"
* }
* ----
*
* `Expression Output`
*
* [source,DataWeave,linenums]
* ----
* "Shoki"
* ----
*/
....

=== How to document your Modules
The module documentation doesn't follow any template.
You just need to place it before the DataWeave version tag.

The following example is documentation of the xref:dw-core.adoc[dw::Core] module
....
/**
 * This module contains core DataWeave functions for data transformations.
 * It is automatically imported into any DataWeave script. For documentation
 * on DataWeave _1.0_ functions, see
 * https://docs.mulesoft.com/dataweave/1.2/dataweave-operators[DataWeave Operators].
 */
%dw 2.0
....

=== How to document your Annotation and Types
Annotation and Types documentation doesn't follow any template too.
You need to write it before the Annotation or Type definition.

The below example is the documentation for _@StreamCapable_ annotation.
....
/**
* Annotation that marks a parameter as stream capable, which means that this
* field will consume an array of objects in a forward-only manner.
*/
@AnnotationTarget(targets = ["Parameter", "Variable"])
annotation StreamCapable()
....

The following example is the documentation for _DataFormat_ type from the xref:dw-dataformat.adoc[dw::extension::DataFormat] module.
....
/**
 * Represents encoding settings.
 */
@Since(version = "2.2.0")
type EncodingSettings = {
    /**
    * Encoding that the writer uses for output. Defaults to "UTF-8".
    */
    encoding?: String {defaultValue: "UTF-8"}
}
....